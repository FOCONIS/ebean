package io.ebean.config;

import com.fasterxml.jackson.core.JsonFactory;
import io.avaje.config.Config;
import io.ebean.*;
import io.ebean.annotation.*;
import io.ebean.cache.ServerCachePlugin;
import io.ebean.config.dbplatform.DatabasePlatform;
import io.ebean.config.dbplatform.DbEncrypt;
import io.ebean.config.dbplatform.DbType;
import io.ebean.config.dbplatform.IdType;
import io.ebean.datasource.DataSourceBuilder;
import io.ebean.event.*;
import io.ebean.event.changelog.ChangeLogListener;
import io.ebean.event.changelog.ChangeLogPrepare;
import io.ebean.event.changelog.ChangeLogRegister;
import io.ebean.event.readaudit.ReadAuditLogger;
import io.ebean.event.readaudit.ReadAuditPrepare;
import io.ebean.meta.MetricNamingMatch;
import io.ebean.util.StringHelper;

import jakarta.persistence.EnumType;
import javax.sql.DataSource;
import java.time.Clock;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Function;

/**
 * The configuration used for creating a Database.
 * <p>
 * Used to programmatically construct an Database and optionally register it
 * with the DB singleton.
 * <p>
 * If you just use DB thout this programmatic configuration Ebean will read
 * the application.properties file and take the configuration from there. This usually
 * includes searching the class path and automatically registering any entity
 * classes and listeners etc.
 * <pre>{@code
 *
 * DatabaseConfig config = new DatabaseConfig();
 *
 * // read the ebean.properties and load
 * // those settings into this DatabaseConfig object
 * config.loadFromProperties();
 *
 * // explicitly register the entity beans to avoid classpath scanning
 * config.addClass(Customer.class);
 * config.addClass(User.class);
 *
 * Database db = DatabaseFactory.create(config);
 *
 * }</pre>
 *
 * <p>
 * Note that DatabaseConfigProvider provides a standard Java ServiceLoader mechanism that can
 * be used to apply configuration to the DatabaseConfig.
 *
 * @author emcgreal
 * @author rbygrave
 * @see DatabaseFactory
 */
public class DatabaseConfig implements DatabaseBuilder.Settings {

  /**
   * The Database name.
   */
  private String name = "db";

  /**
   * Typically configuration type objects that are passed by this DatabaseConfig
   * to plugins. For example - IgniteConfiguration passed to Ignite plugin.
   */
  private final Map<String, Object> serviceObject = new HashMap<>();

  private ContainerConfig containerConfig;

  /**
   * The underlying properties that were used during configuration.
   */
  private Properties properties;

  /**
   * The resource directory.
   */
  private String resourceDirectory;

  /**
   * Set to true to register this Database with the DB singleton.
   */
  private boolean register = true;

  /**
   * Set to true if this is the default/primary database.
   */
  private boolean defaultServer = true;

  /**
   * Set this to true to disable class path search.
   */
  private boolean disableClasspathSearch;

  private TenantMode tenantMode = TenantMode.NONE;

  private String tenantPartitionColumn = "tenant_id";

  private CurrentTenantProvider currentTenantProvider;

  private TenantDataSourceProvider tenantDataSourceProvider;

  private TenantSchemaProvider tenantSchemaProvider;

  private TenantCatalogProvider tenantCatalogProvider;

  /**
   * When true will load entity classes via EntityClassRegister.
   * <p>
   * NB: EntityClassRegister implementations are generated by querybean generator.
   * Having this on and registering entity classes means we don't need to manually
   * write that code or use classpath scanning to find entity classes.
   */
  private boolean loadModuleInfo = true;

  /**
   * Interesting classes such as entities, embedded, ScalarTypes,
   * Listeners, Finders, Controllers, AttributeConverters etc.
   */
  private Set<Class<?>> classes = new HashSet<>();

  /**
   * The packages that are searched for interesting classes. Only used when
   * classes is empty/not explicitly specified.
   */
  private List<String> packages = new ArrayList<>();

  /**
   * Configuration for the ElasticSearch integration.
   */
  private DocStoreConfig docStoreConfig = new DocStoreConfig();

  /**
   * Set to true when the Database only uses Document store.
   */
  private boolean docStoreOnly;

  /**
   * This is used to populate @WhoCreated, @WhoModified and
   * support other audit features (who executed a query etc).
   */
  private CurrentUserProvider currentUserProvider;

  /**
   * Config controlling the AutoTune behaviour.
   */
  private AutoTuneConfig autoTuneConfig = new AutoTuneConfig();

  /**
   * The JSON format used for DateTime types. Default to millis.
   */
  private JsonConfig.DateTime jsonDateTime = JsonConfig.DateTime.ISO8601;

  /**
   * The JSON format used for Date types. Default to millis.
   */
  private JsonConfig.Date jsonDate = JsonConfig.Date.ISO8601;

  /**
   * For writing JSON specify if null values or empty collections should be excluded.
   * By default all values are included.
   */
  private JsonConfig.Include jsonInclude = JsonConfig.Include.ALL;

  /**
   * The default mode used for {@code @DbJson} with Jackson ObjectMapper.
   */
  private MutationDetection jsonMutationDetection = MutationDetection.HASH;

  /**
   * The database platform name. Used to imply a DatabasePlatform to use.
   */
  private String databasePlatformName;

  /**
   * The database platform.
   */
  private DatabasePlatform databasePlatform;

  /**
   * JDBC fetchSize hint when using findList.  Defaults to 0 leaving it up to the JDBC driver.
   */
  private int jdbcFetchSizeFindList;

  /**
   * JDBC fetchSize hint when using findEach/findEachWhile.  Defaults to 100. Note that this does
   * not apply to MySql as that gets special treatment (forward only etc).
   */
  private int jdbcFetchSizeFindEach = 100;

  /**
   * Suffix appended to the base table to derive the view that contains the union
   * of the base table and the history table in order to support asOf queries.
   */
  private String asOfViewSuffix = "_with_history";

  /**
   * Column used to support history and 'As of' queries. This column is a timestamp range
   * or equivalent.
   */
  private String asOfSysPeriod = "sys_period";

  /**
   * Suffix appended to the base table to derive the view that contains the union
   * of the base table and the history table in order to support asOf queries.
   */
  private String historyTableSuffix = "_history";

  /**
   * When true explicit transactions beans that have been made dirty will be
   * automatically persisted via update on flush.
   */
  private boolean autoPersistUpdates;

  /**
   * Use for transaction scoped batch mode.
   */
  private PersistBatch persistBatch = PersistBatch.NONE;

  /**
   * Use for cascade persist JDBC batch mode. INHERIT means use the platform default
   * which is ALL except for SQL Server where it is NONE (as getGeneratedKeys isn't
   * supported on SQL Server with JDBC batch).
   */
  private PersistBatch persistBatchOnCascade = PersistBatch.INHERIT;

  private int persistBatchSize = 20;

  private EnumType defaultEnumType = EnumType.ORDINAL;

  private boolean disableLazyLoading;

  /**
   * The default batch size for lazy loading
   */
  private int lazyLoadBatchSize = 10;

  /**
   * The default batch size for 'query joins'.
   */
  private int queryBatchSize = 100;

  private boolean eagerFetchLobs;

  /**
   * Timezone used to get/set Timestamp values via JDBC.
   */
  private String dataTimeZone;

  private boolean ddlGenerate;

  private boolean ddlRun;

  private boolean ddlExtra = true;

  private boolean ddlCreateOnly;

  private String ddlInitSql;

  private String ddlSeedSql;

  private String ddlHeader;

  /**
   * Mode used to check non-null columns added via migration have a default value specified etc.
   */
  private boolean ddlStrictMode = true;

  /**
   * Comma and equals delimited key/value placeholders to replace in DDL scripts.
   */
  private String ddlPlaceholders;

  /**
   * Map of key/value placeholders to replace in DDL scripts.
   */
  private Map<String, String> ddlPlaceholderMap;

  private boolean runMigration;

  /**
   * When true L2 bean cache use is skipped after a write has occurred on a transaction.
   */
  private boolean skipCacheAfterWrite = true;

  private boolean useJtaTransactionManager;

  /**
   * The external transaction manager (like Spring).
   */
  private ExternalTransactionManager externalTransactionManager;

  private boolean skipDataSourceCheck;

  /**
   * The data source (if programmatically provided).
   */
  private DataSource dataSource;

  /**
   * The read only data source (can be null).
   */
  private DataSource readOnlyDataSource;

  /**
   * The data source config.
   */
  private DataSourceBuilder dataSourceConfig = DataSourceBuilder.create();

  /**
   * When true create a read only DataSource using readOnlyDataSourceConfig defaulting values from dataSourceConfig.
   * I believe this will default to true in some future release (as it has a nice performance benefit).
   * <p>
   * autoReadOnlyDataSource is an unfortunate name for this config option but I haven't come up with a better one.
   */
  private boolean autoReadOnlyDataSource;

  /**
   * Optional configuration for a read only data source.
   */
  private DataSourceBuilder readOnlyDataSourceConfig = DataSourceBuilder.create();

  /**
   * Optional - the database schema that should be used to own the tables etc.
   */
  private String dbSchema;

  /**
   * The ClassLoadConfig used to detect Joda, Java8, Jackson etc and create plugin instances given a className.
   */
  private ClassLoadConfig classLoadConfig = new ClassLoadConfig();

  /**
   * The naming convention.
   */
  private NamingConvention namingConvention = new UnderscoreNamingConvention();

  /**
   * Behaviour of updates in JDBC batch to by default include all properties.
   */
  private boolean updateAllPropertiesInBatch;

  /**
   * Database platform configuration.
   */
  private PlatformConfig platformConfig = new PlatformConfig();

  /**
   * The UUID version to use.
   */
  private UuidVersion uuidVersion = UuidVersion.VERSION4;

  /**
   * The UUID state file (for Version 1 UUIDs). By default, the file is created in
   * ${HOME}/.ebean/${servername}-uuid.state
   */
  private String uuidStateFile;

  /**
   * The node id (=mac address) for Version 1 UUIDs. There are several options:
   * <ul>
   * <li><code>null</code> (default) The generator tries to get the hardwarwe MAC
   * address. If this fails, it will fall back to 'generate' mode.</li>
   * <li><code>"generate"</code> Hardware detection is skipped. It generates a
   * random identifier and tries to persist this to the state file. This nodeId
   * will be reused on next start. If persisting to the state file will fail also,
   * it will fall back to 'random' mode.<br>
   * This mode is good, if the MAC address is not reliable, e.g. if you run
   * multiple ebean instances on the same machine.</li>
   * <li><code>"random"</code> In this mode, a random node id is generated on each
   * start. No stateFile is used. it will generate a new nodeId on each
   * application start.<br>
   * This mode is good, if you have no write access to save the state file.</li>
   * <li><code>"xx-xx-xx-xx-xx-xx"</code> When an explicit nodeId is specified,
   * this one is used.</li>
   * </ul>
   * Note: It is possible that multiple servers are sharing the same state file as
   * long as they are in the <b>same</b> JVM/ClassLoader scope. In this case it is
   * recommended to use the same uuidNodeId configuration.
   * <p>
   * If you have multiple servers in different JVMs, do <b>not</b> share the state
   * files!
   */
  private String uuidNodeId;

  /**
   * The clock used for setting the timestamps (e.g. @UpdatedTimestamp) on objects.
   */
  private Clock clock = Clock.systemUTC();

  private List<IdGenerator> idGenerators = new ArrayList<>();
  private List<BeanFindController> findControllers = new ArrayList<>();
  private List<BeanPersistController> persistControllers = new ArrayList<>();
  private List<BeanPostLoad> postLoaders = new ArrayList<>();
  private List<BeanPostConstructListener> postConstructListeners = new ArrayList<>();
  private List<BeanPersistListener> persistListeners = new ArrayList<>();
  private List<BeanQueryAdapter> queryAdapters = new ArrayList<>();
  private final List<BulkTableEventListener> bulkTableEventListeners = new ArrayList<>();
  private final List<ServerConfigStartup> configStartupListeners = new ArrayList<>();

  /**
   * By default inserts are included in the change log.
   */
  private boolean changeLogIncludeInserts = true;

  private ChangeLogPrepare changeLogPrepare;
  private ChangeLogListener changeLogListener;
  private ChangeLogRegister changeLogRegister;
  private boolean changeLogAsync = true;
  private ReadAuditLogger readAuditLogger;
  private ReadAuditPrepare readAuditPrepare;
  private EncryptKeyManager encryptKeyManager;
  private EncryptDeployManager encryptDeployManager;
  private Encryptor encryptor;
  private DbEncrypt dbEncrypt;
  private boolean dbOffline;
  private ServerCachePlugin serverCachePlugin;

  /**
   * The default PersistenceContextScope used if one is not explicitly set on a query.
   */
  private PersistenceContextScope persistenceContextScope = PersistenceContextScope.TRANSACTION;
  private JsonFactory jsonFactory;
  private boolean localTimeWithNanos;
  private boolean durationWithNanos;
  private int maxCallStack = 5;
  private boolean transactionRollbackOnChecked = true;

  // configuration for the background executor service (thread pool)

  private int backgroundExecutorSchedulePoolSize = 1;
  private int backgroundExecutorShutdownSecs = 30;
  private BackgroundExecutorWrapper backgroundExecutorWrapper = new MdcBackgroundExecutorWrapper();

  // defaults for the L2 bean caching

  private int cacheMaxSize = 10000;
  private int cacheMaxIdleTime = 600;
  private int cacheMaxTimeToLive = 60 * 60 * 6;

  // defaults for the L2 query caching

  private int queryCacheMaxSize = 1000;
  private int queryCacheMaxIdleTime = 600;
  private int queryCacheMaxTimeToLive = 60 * 60 * 6;
  private Object objectMapper;

  /**
   * Set to true if you want eq("someProperty", null) to generate 1=1 rather than "is null" sql expression.
   */
  private boolean expressionEqualsWithNullAsNoop;

  /**
   * Set to true to use native ILIKE expression (if support by database platform / like Postgres).
   */
  private boolean expressionNativeIlike;

  private String jodaLocalTimeMode;

  /**
   * Time to live for query plans - defaults to 5 minutes.
   */
  private int queryPlanTTLSeconds = 60 * 5;

  /**
   * Set to true to globally disable L2 caching (typically for performance testing).
   */
  private boolean disableL2Cache;

  private String enabledL2Regions;

  /**
   * Set to true to effectively disable L2 cache plugins.
   */
  private boolean localOnlyL2Cache;

  /**
   * Should the javax.validation.constraints.NotNull enforce a notNull column in DB.
   * If set to false, use io.ebean.annotation.NotNull or Column(nullable=true).
   */
  private boolean useValidationNotNull = true;

  /**
   * Generally we want to perform L2 cache notification in the background and not impact
   * the performance of executing transactions.
   */
  private boolean notifyL2CacheInForeground;

  /**
   * Set to true to enable bind capture required for query plan capture.
   */
  private boolean queryPlanEnable;

  /**
   * The default threshold in micros for collecting query plans.
   */
  private long queryPlanThresholdMicros = Long.MAX_VALUE;

  /**
   * Set to true to enable automatic periodic query plan capture.
   */
  private boolean queryPlanCapture;
  private long queryPlanCapturePeriodSecs = 60 * 10; // 10 minutes
  private long queryPlanCaptureMaxTimeMillis = 10_000; // 10 seconds
  private int queryPlanCaptureMaxCount = 10;
  private QueryPlanListener queryPlanListener;

  /**
   * The time in millis used to determine when a query is alerted for being slow.
   */
  private long slowQueryMillis;

  /**
   * The listener for processing slow query events.
   */
  private SlowQueryListener slowQueryListener;

  private ProfilingConfig profilingConfig = new ProfilingConfig();

  /**
   * The mappingLocations for searching xml mapping.
   */
  private List<String> mappingLocations = new ArrayList<>();

  /**
   * When true we do not need explicit GeneratedValue mapping.
   */
  private boolean idGeneratorAutomatic = true;

  private boolean dumpMetricsOnShutdown;

  private String dumpMetricsOptions;

  private Function<String, String> metricNaming = MetricNamingMatch.INSTANCE;

  /**
   * Construct a Database Configuration for programmatically creating an Database.
   */
  public DatabaseConfig() {
  }

  @Override
  public Settings settings() {
    return this;
  }

  @Override
  public Clock getClock() {
    return clock;
  }

  @Override
  public void setClock(final Clock clock) {
    this.clock = clock;
  }

  @Override
  public long getSlowQueryMillis() {
    return slowQueryMillis;
  }

  @Override
  public void setSlowQueryMillis(long slowQueryMillis) {
    this.slowQueryMillis = slowQueryMillis;
  }

  @Override
  public SlowQueryListener getSlowQueryListener() {
    return slowQueryListener;
  }

  @Override
  public void setSlowQueryListener(SlowQueryListener slowQueryListener) {
    this.slowQueryListener = slowQueryListener;
  }

  @Override
  public void putServiceObject(String key, Object configObject) {
    serviceObject.put(key, configObject);
  }

  @Override
  public <T> void putServiceObject(Class<T> iface, T configObject) {
    serviceObject.put(serviceObjectKey(iface), configObject);
  }

  @Override
  public Object getServiceObject(String key) {
    return serviceObject.get(key);
  }

  @Override
  public void putServiceObject(Object configObject) {
    String key = serviceObjectKey(configObject);
    serviceObject.put(key, configObject);
  }

  @Override
  @SuppressWarnings("unchecked")
  public <P> P getServiceObject(Class<P> cls) {
    return (P) serviceObject.get(serviceObjectKey(cls));
  }

  private String serviceObjectKey(Object configObject) {
    return serviceObjectKey(configObject.getClass());
  }

  private String serviceObjectKey(Class<?> cls) {
    String simpleName = cls.getSimpleName();
    return Character.toLowerCase(simpleName.charAt(0)) + simpleName.substring(1);
  }

  @Override
  public JsonFactory getJsonFactory() {
    return jsonFactory;
  }

  @Override
  public void setJsonFactory(JsonFactory jsonFactory) {
    this.jsonFactory = jsonFactory;
  }

  @Override
  public JsonConfig.DateTime getJsonDateTime() {
    return jsonDateTime;
  }

  @Override
  public void setJsonDateTime(JsonConfig.DateTime jsonDateTime) {
    this.jsonDateTime = jsonDateTime;
  }

  @Override
  public JsonConfig.Date getJsonDate() {
    return jsonDate;
  }

  @Override
  public void setJsonDate(JsonConfig.Date jsonDate) {
    this.jsonDate = jsonDate;
  }

  @Override
  public JsonConfig.Include getJsonInclude() {
    return jsonInclude;
  }

  @Override
  public void setJsonInclude(JsonConfig.Include jsonInclude) {
    this.jsonInclude = jsonInclude;
  }

  @Override
  public MutationDetection getJsonMutationDetection() {
    return jsonMutationDetection;
  }

  @Override
  public void setJsonMutationDetection(MutationDetection jsonMutationDetection) {
    this.jsonMutationDetection = jsonMutationDetection;
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public void setName(String name) {
    this.name = name;
  }

  @Override
  public ContainerConfig getContainerConfig() {
    return containerConfig;
  }

  @Override
  public void setContainerConfig(ContainerConfig containerConfig) {
    this.containerConfig = containerConfig;
  }

  @Override
  public boolean isRegister() {
    return register;
  }

  @Override
  public void setRegister(boolean register) {
    this.register = register;
  }

  @Override
  public boolean isDefaultServer() {
    return defaultServer;
  }

  @Override
  public void setDefaultServer(boolean defaultServer) {
    this.defaultServer = defaultServer;
  }

  @Override
  public CurrentUserProvider getCurrentUserProvider() {
    return currentUserProvider;
  }

  @Override
  public void setCurrentUserProvider(CurrentUserProvider currentUserProvider) {
    this.currentUserProvider = currentUserProvider;
  }

  @Override
  public TenantMode getTenantMode() {
    return tenantMode;
  }

  @Override
  public void setTenantMode(TenantMode tenantMode) {
    this.tenantMode = tenantMode;
  }

  @Override
  public String getTenantPartitionColumn() {
    return tenantPartitionColumn;
  }

  @Override
  public void setTenantPartitionColumn(String tenantPartitionColumn) {
    this.tenantPartitionColumn = tenantPartitionColumn;
  }

  @Override
  public CurrentTenantProvider getCurrentTenantProvider() {
    return currentTenantProvider;
  }

  @Override
  public void setCurrentTenantProvider(CurrentTenantProvider currentTenantProvider) {
    this.currentTenantProvider = currentTenantProvider;
  }

  @Override
  public TenantDataSourceProvider getTenantDataSourceProvider() {
    return tenantDataSourceProvider;
  }

  @Override
  public void setTenantDataSourceProvider(TenantDataSourceProvider tenantDataSourceProvider) {
    this.tenantDataSourceProvider = tenantDataSourceProvider;
  }

  @Override
  public TenantSchemaProvider getTenantSchemaProvider() {
    return tenantSchemaProvider;
  }

  @Override
  public void setTenantSchemaProvider(TenantSchemaProvider tenantSchemaProvider) {
    this.tenantSchemaProvider = tenantSchemaProvider;
  }

  @Override
  public TenantCatalogProvider getTenantCatalogProvider() {
    return tenantCatalogProvider;
  }

  @Override
  public void setTenantCatalogProvider(TenantCatalogProvider tenantCatalogProvider) {
    this.tenantCatalogProvider = tenantCatalogProvider;
  }

  @Override
  public boolean isAutoPersistUpdates() {
    return autoPersistUpdates;
  }

  @Override
  public void setAutoPersistUpdates(boolean autoPersistUpdates) {
    this.autoPersistUpdates = autoPersistUpdates;
  }

  @Override
  public PersistBatch getPersistBatch() {
    return persistBatch;
  }

  @Override
  public void setPersistBatch(PersistBatch persistBatch) {
    this.persistBatch = persistBatch;
  }

  @Override
  public PersistBatch getPersistBatchOnCascade() {
    return persistBatchOnCascade;
  }

  @Override
  public void setPersistBatchOnCascade(PersistBatch persistBatchOnCascade) {
    this.persistBatchOnCascade = persistBatchOnCascade;
  }

  @Override
  public void setPersistBatching(boolean persistBatching) {
    this.persistBatch = (persistBatching) ? PersistBatch.ALL : PersistBatch.NONE;
  }

  @Override
  public int getPersistBatchSize() {
    return persistBatchSize;
  }

  @Override
  public void setPersistBatchSize(int persistBatchSize) {
    this.persistBatchSize = persistBatchSize;
  }

  @Override
  public int getQueryBatchSize() {
    return queryBatchSize;
  }

  @Override
  public void setQueryBatchSize(int queryBatchSize) {
    this.queryBatchSize = queryBatchSize;
  }

  @Override
  public EnumType getDefaultEnumType() {
    return defaultEnumType;
  }

  @Override
  public void setDefaultEnumType(EnumType defaultEnumType) {
    this.defaultEnumType = defaultEnumType;
  }

  @Override
  public boolean isDisableLazyLoading() {
    return disableLazyLoading;
  }

  @Override
  public void setDisableLazyLoading(boolean disableLazyLoading) {
    this.disableLazyLoading = disableLazyLoading;
  }

  @Override
  public int getLazyLoadBatchSize() {
    return lazyLoadBatchSize;
  }

  @Override
  public void setLazyLoadBatchSize(int lazyLoadBatchSize) {
    this.lazyLoadBatchSize = lazyLoadBatchSize;
  }

  @Override
  public void setDatabaseSequenceBatchSize(int databaseSequenceBatchSize) {
    platformConfig.setDatabaseSequenceBatchSize(databaseSequenceBatchSize);
  }

  @Override
  public int getJdbcFetchSizeFindList() {
    return jdbcFetchSizeFindList;
  }

  @Override
  public void setJdbcFetchSizeFindList(int jdbcFetchSizeFindList) {
    this.jdbcFetchSizeFindList = jdbcFetchSizeFindList;
  }

  @Override
  public int getJdbcFetchSizeFindEach() {
    return jdbcFetchSizeFindEach;
  }

  @Override
  public void setJdbcFetchSizeFindEach(int jdbcFetchSizeFindEach) {
    this.jdbcFetchSizeFindEach = jdbcFetchSizeFindEach;
  }

  @Override
  public ChangeLogPrepare getChangeLogPrepare() {
    return changeLogPrepare;
  }

  @Override
  public void setChangeLogPrepare(ChangeLogPrepare changeLogPrepare) {
    this.changeLogPrepare = changeLogPrepare;
  }

  @Override
  public ChangeLogListener getChangeLogListener() {
    return changeLogListener;
  }

  @Override
  public void setChangeLogListener(ChangeLogListener changeLogListener) {
    this.changeLogListener = changeLogListener;
  }

  @Override
  public ChangeLogRegister getChangeLogRegister() {
    return changeLogRegister;
  }

  @Override
  public void setChangeLogRegister(ChangeLogRegister changeLogRegister) {
    this.changeLogRegister = changeLogRegister;
  }

  @Override
  public boolean isChangeLogIncludeInserts() {
    return changeLogIncludeInserts;
  }

  @Override
  public void setChangeLogIncludeInserts(boolean changeLogIncludeInserts) {
    this.changeLogIncludeInserts = changeLogIncludeInserts;
  }

  @Override
  public boolean isChangeLogAsync() {
    return changeLogAsync;
  }

  @Override
  public void setChangeLogAsync(boolean changeLogAsync) {
    this.changeLogAsync = changeLogAsync;
  }

  @Override
  public ReadAuditLogger getReadAuditLogger() {
    return readAuditLogger;
  }

  @Override
  public void setReadAuditLogger(ReadAuditLogger readAuditLogger) {
    this.readAuditLogger = readAuditLogger;
  }

  @Override
  public ReadAuditPrepare getReadAuditPrepare() {
    return readAuditPrepare;
  }

  @Override
  public void setReadAuditPrepare(ReadAuditPrepare readAuditPrepare) {
    this.readAuditPrepare = readAuditPrepare;
  }

  @Override
  public ProfilingConfig getProfilingConfig() {
    return profilingConfig;
  }

  @Override
  public void setProfilingConfig(ProfilingConfig profilingConfig) {
    this.profilingConfig = profilingConfig;
  }

  @Override
  public String getDbSchema() {
    return dbSchema;
  }

  @Override
  public void setDbSchema(String dbSchema) {
    this.dbSchema = dbSchema;
  }

  @Override
  public int getGeometrySRID() {
    return platformConfig.getGeometrySRID();
  }

  @Override
  public void setGeometrySRID(int geometrySRID) {
    platformConfig.setGeometrySRID(geometrySRID);
  }

  @Override
  public String getDataTimeZone() {
    return System.getProperty("ebean.dataTimeZone", dataTimeZone);
  }

  @Override
  public void setDataTimeZone(String dataTimeZone) {
    this.dataTimeZone = dataTimeZone;
  }

  @Override
  public String getAsOfViewSuffix() {
    return asOfViewSuffix;
  }

  @Override
  public void setAsOfViewSuffix(String asOfViewSuffix) {
    this.asOfViewSuffix = asOfViewSuffix;
  }

  @Override
  public String getAsOfSysPeriod() {
    return asOfSysPeriod;
  }

  @Override
  public void setAsOfSysPeriod(String asOfSysPeriod) {
    this.asOfSysPeriod = asOfSysPeriod;
  }

  @Override
  public String getHistoryTableSuffix() {
    return historyTableSuffix;
  }

  @Override
  public void setHistoryTableSuffix(String historyTableSuffix) {
    this.historyTableSuffix = historyTableSuffix;
  }

  @Override
  public boolean isUseJtaTransactionManager() {
    return useJtaTransactionManager;
  }

  @Override
  public void setUseJtaTransactionManager(boolean useJtaTransactionManager) {
    this.useJtaTransactionManager = useJtaTransactionManager;
  }

  @Override
  public ExternalTransactionManager getExternalTransactionManager() {
    return externalTransactionManager;
  }

  @Override
  public void setExternalTransactionManager(ExternalTransactionManager externalTransactionManager) {
    this.externalTransactionManager = externalTransactionManager;
  }

  @Override
  public ServerCachePlugin getServerCachePlugin() {
    return serverCachePlugin;
  }

  @Override
  public void setServerCachePlugin(ServerCachePlugin serverCachePlugin) {
    this.serverCachePlugin = serverCachePlugin;
  }

  @Override
  public boolean isEagerFetchLobs() {
    return eagerFetchLobs;
  }

  @Override
  public void setEagerFetchLobs(boolean eagerFetchLobs) {
    this.eagerFetchLobs = eagerFetchLobs;
  }

  @Override
  public int getMaxCallStack() {
    return maxCallStack;
  }

  @Override
  public void setMaxCallStack(int maxCallStack) {
    this.maxCallStack = maxCallStack;
  }

  @Override
  public boolean isTransactionRollbackOnChecked() {
    return transactionRollbackOnChecked;
  }

  @Override
  public void setTransactionRollbackOnChecked(boolean transactionRollbackOnChecked) {
    this.transactionRollbackOnChecked = transactionRollbackOnChecked;
  }

  @Override
  public int getBackgroundExecutorSchedulePoolSize() {
    return backgroundExecutorSchedulePoolSize;
  }

  @Override
  public void setBackgroundExecutorSchedulePoolSize(int backgroundExecutorSchedulePoolSize) {
    this.backgroundExecutorSchedulePoolSize = backgroundExecutorSchedulePoolSize;
  }

  @Override
  public int getBackgroundExecutorShutdownSecs() {
    return backgroundExecutorShutdownSecs;
  }

  @Override
  public void setBackgroundExecutorShutdownSecs(int backgroundExecutorShutdownSecs) {
    this.backgroundExecutorShutdownSecs = backgroundExecutorShutdownSecs;
  }

  @Override
  public BackgroundExecutorWrapper getBackgroundExecutorWrapper() {
    return backgroundExecutorWrapper;
  }

  @Override
  public void setBackgroundExecutorWrapper(BackgroundExecutorWrapper backgroundExecutorWrapper) {
    this.backgroundExecutorWrapper = backgroundExecutorWrapper;
  }

  @Override
  public int getCacheMaxSize() {
    return cacheMaxSize;
  }

  @Override
  public void setCacheMaxSize(int cacheMaxSize) {
    this.cacheMaxSize = cacheMaxSize;
  }

  @Override
  public int getCacheMaxIdleTime() {
    return cacheMaxIdleTime;
  }

  @Override
  public void setCacheMaxIdleTime(int cacheMaxIdleTime) {
    this.cacheMaxIdleTime = cacheMaxIdleTime;
  }

  @Override
  public int getCacheMaxTimeToLive() {
    return cacheMaxTimeToLive;
  }

  @Override
  public void setCacheMaxTimeToLive(int cacheMaxTimeToLive) {
    this.cacheMaxTimeToLive = cacheMaxTimeToLive;
  }

  @Override
  public int getQueryCacheMaxSize() {
    return queryCacheMaxSize;
  }

  @Override
  public void setQueryCacheMaxSize(int queryCacheMaxSize) {
    this.queryCacheMaxSize = queryCacheMaxSize;
  }

  @Override
  public int getQueryCacheMaxIdleTime() {
    return queryCacheMaxIdleTime;
  }

  @Override
  public void setQueryCacheMaxIdleTime(int queryCacheMaxIdleTime) {
    this.queryCacheMaxIdleTime = queryCacheMaxIdleTime;
  }

  @Override
  public int getQueryCacheMaxTimeToLive() {
    return queryCacheMaxTimeToLive;
  }

  @Override
  public void setQueryCacheMaxTimeToLive(int queryCacheMaxTimeToLive) {
    this.queryCacheMaxTimeToLive = queryCacheMaxTimeToLive;
  }

  @Override
  public NamingConvention getNamingConvention() {
    return namingConvention;
  }

  @Override
  public void setNamingConvention(NamingConvention namingConvention) {
    this.namingConvention = namingConvention;
  }

  @Override
  public boolean isAllQuotedIdentifiers() {
    return platformConfig.isAllQuotedIdentifiers();
  }

  @Override
  public void setAllQuotedIdentifiers(boolean allQuotedIdentifiers) {
    platformConfig.setAllQuotedIdentifiers(allQuotedIdentifiers);
    if (allQuotedIdentifiers) {
      adjustNamingConventionForAllQuoted();
    }
  }

  private void adjustNamingConventionForAllQuoted() {
    if (namingConvention instanceof UnderscoreNamingConvention) {
      // we need to use matching naming convention
      this.namingConvention = new MatchingNamingConvention();
    }
  }

  @Override
  public boolean isDocStoreOnly() {
    return docStoreOnly;
  }

  @Override
  public void setDocStoreOnly(boolean docStoreOnly) {
    this.docStoreOnly = docStoreOnly;
  }

  @Override
  public DocStoreConfig getDocStoreConfig() {
    return docStoreConfig;
  }

  @Override
  public void setDocStoreConfig(DocStoreConfig docStoreConfig) {
    this.docStoreConfig = docStoreConfig;
  }

  @Override
  public DbConstraintNaming getConstraintNaming() {
    return platformConfig.getConstraintNaming();
  }

  @Override
  public void setConstraintNaming(DbConstraintNaming constraintNaming) {
    platformConfig.setConstraintNaming(constraintNaming);
  }

  @Override
  public AutoTuneConfig getAutoTuneConfig() {
    return autoTuneConfig;
  }

  @Override
  public void setAutoTuneConfig(AutoTuneConfig autoTuneConfig) {
    this.autoTuneConfig = autoTuneConfig;
  }

  @Override
  public boolean skipDataSourceCheck() {
    return skipDataSourceCheck;
  }

  @Override
  public void setSkipDataSourceCheck(boolean skipDataSourceCheck) {
    this.skipDataSourceCheck = skipDataSourceCheck;
  }

  @Override
  public DataSource getDataSource() {
    return dataSource;
  }

  @Override
  public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  @Override
  public DataSource getReadOnlyDataSource() {
    return readOnlyDataSource;
  }

  @Override
  public void setReadOnlyDataSource(DataSource readOnlyDataSource) {
    this.readOnlyDataSource = readOnlyDataSource;
  }

  @Override
  public DataSourceBuilder getDataSourceConfig() {
    return dataSourceConfig;
  }

  @Override
  public void setDataSourceConfig(DataSourceBuilder dataSourceConfig) {
    this.dataSourceConfig = dataSourceConfig;
  }

  @Override
  public boolean isAutoReadOnlyDataSource() {
    return autoReadOnlyDataSource;
  }

  @Override
  public void setAutoReadOnlyDataSource(boolean autoReadOnlyDataSource) {
    this.autoReadOnlyDataSource = autoReadOnlyDataSource;
  }

  @Override
  public DataSourceBuilder getReadOnlyDataSourceConfig() {
    return readOnlyDataSourceConfig;
  }

  @Override
  public void setReadOnlyDataSourceConfig(DataSourceBuilder readOnlyDataSourceConfig) {
    this.readOnlyDataSourceConfig = readOnlyDataSourceConfig;
  }

  @Override
  public String getDatabaseBooleanTrue() {
    return platformConfig.getDatabaseBooleanTrue();
  }

  @Override
  public void setDatabaseBooleanTrue(String databaseTrue) {
    platformConfig.setDatabaseBooleanTrue(databaseTrue);
  }

  @Override
  public String getDatabaseBooleanFalse() {
    return platformConfig.getDatabaseBooleanFalse();
  }

  @Override
  public void setDatabaseBooleanFalse(String databaseFalse) {
    this.platformConfig.setDatabaseBooleanFalse(databaseFalse);
  }

  @Override
  public int getDatabaseSequenceBatchSize() {
    return platformConfig.getDatabaseSequenceBatchSize();
  }

  @Override
  public void setDatabaseSequenceBatch(int databaseSequenceBatchSize) {
    this.platformConfig.setDatabaseSequenceBatchSize(databaseSequenceBatchSize);
  }

  @Override
  public String getDatabasePlatformName() {
    return databasePlatformName;
  }

  @Override
  public void setDatabasePlatformName(String databasePlatformName) {
    this.databasePlatformName = databasePlatformName;
  }

  @Override
  public DatabasePlatform getDatabasePlatform() {
    return databasePlatform;
  }

  @Override
  public void setDatabasePlatform(DatabasePlatform databasePlatform) {
    this.databasePlatform = databasePlatform;
  }

  @Override
  public IdType getIdType() {
    return platformConfig.getIdType();
  }

  @Override
  public void setIdType(IdType idType) {
    this.platformConfig.setIdType(idType);
  }

  @Override
  public EncryptKeyManager getEncryptKeyManager() {
    return encryptKeyManager;
  }

  @Override
  public void setEncryptKeyManager(EncryptKeyManager encryptKeyManager) {
    this.encryptKeyManager = encryptKeyManager;
  }

  @Override
  public EncryptDeployManager getEncryptDeployManager() {
    return encryptDeployManager;
  }

  @Override
  public void setEncryptDeployManager(EncryptDeployManager encryptDeployManager) {
    this.encryptDeployManager = encryptDeployManager;
  }

  @Override
  public Encryptor getEncryptor() {
    return encryptor;
  }

  @Override
  public void setEncryptor(Encryptor encryptor) {
    this.encryptor = encryptor;
  }

  @Override
  public boolean isDbOffline() {
    return dbOffline;
  }

  @Override
  public void setDbOffline(boolean dbOffline) {
    this.dbOffline = dbOffline;
  }

  @Override
  public DbEncrypt getDbEncrypt() {
    return dbEncrypt;
  }

  @Override
  public void setDbEncrypt(DbEncrypt dbEncrypt) {
    this.dbEncrypt = dbEncrypt;
  }

  @Override
  public PlatformConfig getPlatformConfig() {
    return platformConfig;
  }

  @Override
  public void setPlatformConfig(PlatformConfig platformConfig) {
    this.platformConfig = platformConfig;
  }

  @Override
  public void setDbUuid(PlatformConfig.DbUuid dbUuid) {
    this.platformConfig.setDbUuid(dbUuid);
  }

  @Override
  public UuidVersion getUuidVersion() {
    return uuidVersion;
  }

  @Override
  public void setUuidVersion(UuidVersion uuidVersion) {
    this.uuidVersion = uuidVersion;
  }

  @Override
  public String getUuidStateFile() {
    if (uuidStateFile == null || uuidStateFile.isEmpty()) {
      // by default, add servername...
      uuidStateFile = name + "-uuid.state";
      // and store it in the user's home directory
      String homeDir = System.getProperty("user.home");
      if (homeDir != null && homeDir.isEmpty()) {
        uuidStateFile = homeDir + "/.ebean/" + uuidStateFile;
      }
    }
    return uuidStateFile;
  }

  @Override
  public void setUuidStateFile(String uuidStateFile) {
    this.uuidStateFile = uuidStateFile;
  }

  @Override
  public String getUuidNodeId() {
    return uuidNodeId;
  }

  @Override
  public void setUuidNodeId(String uuidNodeId) {
    this.uuidNodeId = uuidNodeId;
  }

  @Override
  public boolean isLocalTimeWithNanos() {
    return localTimeWithNanos;
  }

  @Override
  public void setLocalTimeWithNanos(boolean localTimeWithNanos) {
    this.localTimeWithNanos = localTimeWithNanos;
  }

  @Override
  public boolean isDurationWithNanos() {
    return durationWithNanos;
  }

  @Override
  public void setDurationWithNanos(boolean durationWithNanos) {
    this.durationWithNanos = durationWithNanos;
  }

  @Override
  public void setRunMigration(boolean runMigration) {
    this.runMigration = runMigration;
  }

  @Override
  public boolean isRunMigration() {
    final String run = System.getProperty("ebean.migration.run");
    return (run != null) ? Boolean.parseBoolean(run) : runMigration;
  }

  @Override
  public void setDdlGenerate(boolean ddlGenerate) {
    this.ddlGenerate = ddlGenerate;
  }

  @Override
  public void setDdlRun(boolean ddlRun) {
    this.ddlRun = ddlRun;
  }

  @Override
  public void setDdlExtra(boolean ddlExtra) {
    this.ddlExtra = ddlExtra;
  }


  @Override
  public boolean isDdlCreateOnly() {
    return ddlCreateOnly;
  }

  @Override
  public void setDdlCreateOnly(boolean ddlCreateOnly) {
    this.ddlCreateOnly = ddlCreateOnly;
  }

  @Override
  public String getDdlSeedSql() {
    return ddlSeedSql;
  }

  @Override
  public void setDdlSeedSql(String ddlSeedSql) {
    this.ddlSeedSql = ddlSeedSql;
  }

  @Override
  public String getDdlInitSql() {
    return ddlInitSql;
  }

  @Override
  public void setDdlInitSql(String ddlInitSql) {
    this.ddlInitSql = ddlInitSql;
  }

  @Override
  public boolean isDdlGenerate() {
    return ddlGenerate;
  }

  @Override
  public boolean isDdlRun() {
    return ddlRun;
  }

  @Override
  public boolean isDdlExtra() {
    return ddlExtra;
  }

  @Override
  public void setDdlHeader(String ddlHeader) {
    this.ddlHeader = ddlHeader;
  }

  @Override
  public String getDdlHeader() {
    if (ddlHeader != null && !ddlHeader.isEmpty()) {
      String header = ddlHeader.replace("${version}", EbeanVersion.getVersion());
      header = header.replace("${timestamp}", ZonedDateTime.now().format(DateTimeFormatter.ISO_INSTANT));
      return header;
    }
    return ddlHeader;
  }

  @Override
  public boolean isDdlStrictMode() {
    return ddlStrictMode;
  }

  @Override
  public void setDdlStrictMode(boolean ddlStrictMode) {
    this.ddlStrictMode = ddlStrictMode;
  }

  @Override
  public String getDdlPlaceholders() {
    return ddlPlaceholders;
  }

  @Override
  public void setDdlPlaceholders(String ddlPlaceholders) {
    this.ddlPlaceholders = ddlPlaceholders;
  }

  @Override
  public Map<String, String> getDdlPlaceholderMap() {
    return ddlPlaceholderMap;
  }

  @Override
  public void setDdlPlaceholderMap(Map<String, String> ddlPlaceholderMap) {
    this.ddlPlaceholderMap = ddlPlaceholderMap;
  }

  @Override
  public boolean isDisableClasspathSearch() {
    return disableClasspathSearch;
  }

  @Override
  public void setDisableClasspathSearch(boolean disableClasspathSearch) {
    this.disableClasspathSearch = disableClasspathSearch;
  }

  @Override
  public String getJodaLocalTimeMode() {
    return jodaLocalTimeMode;
  }

  @Override
  public void setJodaLocalTimeMode(String jodaLocalTimeMode) {
    this.jodaLocalTimeMode = jodaLocalTimeMode;
  }

  @Override
  public void addClass(Class<?> cls) {
    classes.add(cls);
  }

  @Override
  public void addAll(Collection<Class<?>> classList) {
    if (classList != null && !classList.isEmpty()) {
      classes.addAll(classList);
    }
  }

  @Override
  public void addPackage(String packageName) {
    packages.add(packageName);
  }

  @Override
  public List<String> getPackages() {
    return packages;
  }

  @Override
  public void setPackages(List<String> packages) {
    this.packages = packages;
  }

  @Override
  public void setClasses(Collection<Class<?>> classes) {
    this.classes = new HashSet<>(classes);
  }

  @Override
  public Set<Class<?>> classes() {
    return classes;
  }

  /**
   * @deprecated - migrate to {@link #classes()}.
   */
  @Override
  @SuppressWarnings("removal")
  @Deprecated(forRemoval = true)
  public Set<Class<?>> getClasses() {
    return classes;
  }

  @Override
  public boolean isSkipCacheAfterWrite() {
    return skipCacheAfterWrite;
  }

  @Override
  public void setSkipCacheAfterWrite(boolean skipCacheAfterWrite) {
    this.skipCacheAfterWrite = skipCacheAfterWrite;
  }

  @Override
  public boolean isUpdateAllPropertiesInBatch() {
    return updateAllPropertiesInBatch;
  }

  @Override
  public void setUpdateAllPropertiesInBatch(boolean updateAllPropertiesInBatch) {
    this.updateAllPropertiesInBatch = updateAllPropertiesInBatch;
  }

  @Override
  public String getResourceDirectory() {
    return resourceDirectory;
  }

  @Override
  public void setResourceDirectory(String resourceDirectory) {
    this.resourceDirectory = resourceDirectory;
  }

  @Override
  public void addCustomMapping(DbType type, String columnDefinition, Platform platform) {
    platformConfig.addCustomMapping(type, columnDefinition, platform);
  }

  @Override
  public void addCustomMapping(DbType type, String columnDefinition) {
    platformConfig.addCustomMapping(type, columnDefinition);
  }

  @Override
  public void add(BeanQueryAdapter beanQueryAdapter) {
    queryAdapters.add(beanQueryAdapter);
  }

  @Override
  public List<BeanQueryAdapter> getQueryAdapters() {
    return queryAdapters;
  }

  @Override
  public void setQueryAdapters(List<BeanQueryAdapter> queryAdapters) {
    this.queryAdapters = queryAdapters;
  }

  @Override
  public List<IdGenerator> getIdGenerators() {
    return idGenerators;
  }

  @Override
  public void setIdGenerators(List<IdGenerator> idGenerators) {
    this.idGenerators = idGenerators;
  }

  @Override
  public void add(IdGenerator idGenerator) {
    idGenerators.add(idGenerator);
  }

  @Override
  public void add(BeanPersistController beanPersistController) {
    persistControllers.add(beanPersistController);
  }

  @Override
  public void add(BeanPostLoad postLoad) {
    postLoaders.add(postLoad);
  }

  @Override
  public void add(BeanPostConstructListener listener) {
    postConstructListeners.add(listener);
  }

  @Override
  public List<BeanFindController> getFindControllers() {
    return findControllers;
  }

  @Override
  public void setFindControllers(List<BeanFindController> findControllers) {
    this.findControllers = findControllers;
  }

  @Override
  public List<BeanPostLoad> getPostLoaders() {
    return postLoaders;
  }

  @Override
  public void setPostLoaders(List<BeanPostLoad> postLoaders) {
    this.postLoaders = postLoaders;
  }

  @Override
  public List<BeanPostConstructListener> getPostConstructListeners() {
    return postConstructListeners;
  }

  @Override
  public void setPostConstructListeners(List<BeanPostConstructListener> listeners) {
    this.postConstructListeners = listeners;
  }

  @Override
  public List<BeanPersistController> getPersistControllers() {
    return persistControllers;
  }

  @Override
  public void setPersistControllers(List<BeanPersistController> persistControllers) {
    this.persistControllers = persistControllers;
  }

  @Override
  public void add(BeanPersistListener beanPersistListener) {
    persistListeners.add(beanPersistListener);
  }

  @Override
  public List<BeanPersistListener> getPersistListeners() {
    return persistListeners;
  }

  @Override
  public void add(BulkTableEventListener bulkTableEventListener) {
    bulkTableEventListeners.add(bulkTableEventListener);
  }

  @Override
  public List<BulkTableEventListener> getBulkTableEventListeners() {
    return bulkTableEventListeners;
  }

  @Override
  public void addServerConfigStartup(ServerConfigStartup configStartupListener) {
    configStartupListeners.add(configStartupListener);
  }

  @Override
  public List<ServerConfigStartup> getServerConfigStartupListeners() {
    return configStartupListeners;
  }

  @Override
  public void setPersistListeners(List<BeanPersistListener> persistListeners) {
    this.persistListeners = persistListeners;
  }

  @Override
  public PersistenceContextScope getPersistenceContextScope() {
    // if somehow null return TRANSACTION scope
    return persistenceContextScope == null ? PersistenceContextScope.TRANSACTION : persistenceContextScope;
  }

  @Override
  public void setPersistenceContextScope(PersistenceContextScope persistenceContextScope) {
    this.persistenceContextScope = persistenceContextScope;
  }

  @Override
  public ClassLoadConfig getClassLoadConfig() {
    return classLoadConfig;
  }

  @Override
  public void setClassLoadConfig(ClassLoadConfig classLoadConfig) {
    this.classLoadConfig = classLoadConfig;
  }

  @Override
  public void loadFromProperties() {
    this.properties = Config.asProperties();
    configureFromProperties();
  }

  @Override
  public void loadFromProperties(Properties properties) {
    // keep the properties used for configuration so that these are available for plugins
    this.properties = Config.asConfiguration().eval(properties);
    configureFromProperties();
  }

  /**
   * Load the settings from the given properties
   */
  private void configureFromProperties() {
    List<AutoConfigure> autoConfigures = autoConfiguration();
    loadSettings(new PropertiesWrapper("ebean", name, properties, classLoadConfig));
    for (AutoConfigure autoConfigure : autoConfigures) {
      autoConfigure.postConfigure(this);
    }
  }

  /**
   * Use a 'plugin' to provide automatic configuration. Intended for automatic testing
   * configuration with Docker containers via ebean-test-config.
   */
  private List<AutoConfigure> autoConfiguration() {
    List<AutoConfigure> list = new ArrayList<>();
    for (AutoConfigure autoConfigure : ServiceLoader.load(AutoConfigure.class)) {
      autoConfigure.preConfigure(this);
      list.add(autoConfigure);
    }
    return list;
  }

  @Override
  public Properties getProperties() {
    return properties;
  }

  /**
   * loads the data source settings to preserve existing behaviour. IMHO, if someone has set the datasource config already,
   * they don't want the settings to be reloaded and reset. This allows a descending class to override this behaviour and prevent it
   * from happening.
   *
   * @param p - The defined property source passed to load settings
   */
  protected void loadDataSourceSettings(PropertiesWrapper p) {
    dataSourceConfig.loadSettings(p.properties, name);
    readOnlyDataSourceConfig.loadSettings(p.properties, name + "-ro");
  }

  /**
   * This is broken out to allow overridden behaviour.
   */
  protected void loadDocStoreSettings(PropertiesWrapper p) {
    docStoreConfig.loadSettings(p);
  }

  /**
   * This is broken out to allow overridden behaviour.
   */
  protected void loadAutoTuneSettings(PropertiesWrapper p) {
    autoTuneConfig.loadSettings(p);
  }

  /**
   * Load the configuration settings from the properties file.
   */
  protected void loadSettings(PropertiesWrapper p) {
    dbSchema = p.get("dbSchema", dbSchema);
    profilingConfig.loadSettings(p, name);
    platformConfig.loadSettings(p);
    if (platformConfig.isAllQuotedIdentifiers()) {
      adjustNamingConventionForAllQuoted();
    }
    namingConvention = createNamingConvention(p, namingConvention);
    if (namingConvention != null) {
      namingConvention.loadFromProperties(p);
    }
    if (autoTuneConfig == null) {
      autoTuneConfig = new AutoTuneConfig();
    }
    loadAutoTuneSettings(p);

    if (dataSourceConfig == null) {
      dataSourceConfig = DataSourceBuilder.create();
    }
    loadDataSourceSettings(p);

    if (docStoreConfig == null) {
      docStoreConfig = new DocStoreConfig();
    }
    loadDocStoreSettings(p);

    defaultServer = p.getBoolean("defaultServer", defaultServer);
    autoPersistUpdates = p.getBoolean("autoPersistUpdates", autoPersistUpdates);
    loadModuleInfo = p.getBoolean("loadModuleInfo", loadModuleInfo);
    maxCallStack = p.getInt("maxCallStack", maxCallStack);
    dumpMetricsOnShutdown = p.getBoolean("dumpMetricsOnShutdown", dumpMetricsOnShutdown);
    dumpMetricsOptions = p.get("dumpMetricsOptions", dumpMetricsOptions);
    queryPlanTTLSeconds = p.getInt("queryPlanTTLSeconds", queryPlanTTLSeconds);
    slowQueryMillis = p.getLong("slowQueryMillis", slowQueryMillis);
    queryPlanEnable = p.getBoolean("queryPlan.enable", queryPlanEnable);
    queryPlanThresholdMicros = p.getLong("queryPlan.thresholdMicros", queryPlanThresholdMicros);
    queryPlanCapture = p.getBoolean("queryPlan.capture", queryPlanCapture);
    queryPlanCapturePeriodSecs = p.getLong("queryPlan.capturePeriodSecs", queryPlanCapturePeriodSecs);
    queryPlanCaptureMaxTimeMillis = p.getLong("queryPlan.captureMaxTimeMillis", queryPlanCaptureMaxTimeMillis);
    queryPlanCaptureMaxCount = p.getInt("queryPlan.captureMaxCount", queryPlanCaptureMaxCount);
    docStoreOnly = p.getBoolean("docStoreOnly", docStoreOnly);
    disableL2Cache = p.getBoolean("disableL2Cache", disableL2Cache);
    localOnlyL2Cache = p.getBoolean("localOnlyL2Cache", localOnlyL2Cache);
    enabledL2Regions = p.get("enabledL2Regions", enabledL2Regions);
    notifyL2CacheInForeground = p.getBoolean("notifyL2CacheInForeground", notifyL2CacheInForeground);
    useJtaTransactionManager = p.getBoolean("useJtaTransactionManager", useJtaTransactionManager);
    useValidationNotNull = p.getBoolean("useValidationNotNull", useValidationNotNull);
    autoReadOnlyDataSource = p.getBoolean("autoReadOnlyDataSource", autoReadOnlyDataSource);
    idGeneratorAutomatic = p.getBoolean("idGeneratorAutomatic", idGeneratorAutomatic);

    backgroundExecutorSchedulePoolSize = p.getInt("backgroundExecutorSchedulePoolSize", backgroundExecutorSchedulePoolSize);
    backgroundExecutorShutdownSecs = p.getInt("backgroundExecutorShutdownSecs", backgroundExecutorShutdownSecs);
    backgroundExecutorWrapper = p.createInstance(BackgroundExecutorWrapper.class, "backgroundExecutorWrapper", backgroundExecutorWrapper);
    disableClasspathSearch = p.getBoolean("disableClasspathSearch", disableClasspathSearch);
    currentUserProvider = p.createInstance(CurrentUserProvider.class, "currentUserProvider", currentUserProvider);
    databasePlatform = p.createInstance(DatabasePlatform.class, "databasePlatform", databasePlatform);
    encryptKeyManager = p.createInstance(EncryptKeyManager.class, "encryptKeyManager", encryptKeyManager);
    encryptDeployManager = p.createInstance(EncryptDeployManager.class, "encryptDeployManager", encryptDeployManager);
    encryptor = p.createInstance(Encryptor.class, "encryptor", encryptor);
    dbEncrypt = p.createInstance(DbEncrypt.class, "dbEncrypt", dbEncrypt);
    dbOffline = p.getBoolean("dbOffline", dbOffline);
    serverCachePlugin = p.createInstance(ServerCachePlugin.class, "serverCachePlugin", serverCachePlugin);

    String packagesProp = p.get("search.packages", p.get("packages", null));
    packages = searchList(packagesProp, packages);

    skipCacheAfterWrite = p.getBoolean("skipCacheAfterWrite", skipCacheAfterWrite);
    updateAllPropertiesInBatch = p.getBoolean("updateAllPropertiesInBatch", updateAllPropertiesInBatch);

    if (p.get("batch.mode") != null || p.get("persistBatching") != null) {
      throw new IllegalArgumentException("Property 'batch.mode' or 'persistBatching' is being set but no longer used. Please change to use 'persistBatchMode'");
    }

    persistBatch = p.getEnum(PersistBatch.class, "persistBatch", persistBatch);
    persistBatchOnCascade = p.getEnum(PersistBatch.class, "persistBatchOnCascade", persistBatchOnCascade);

    int batchSize = p.getInt("batch.size", persistBatchSize);
    persistBatchSize = p.getInt("persistBatchSize", batchSize);

    persistenceContextScope = PersistenceContextScope.valueOf(p.get("persistenceContextScope", "TRANSACTION"));

    changeLogAsync = p.getBoolean("changeLogAsync", changeLogAsync);
    changeLogIncludeInserts = p.getBoolean("changeLogIncludeInserts", changeLogIncludeInserts);
    expressionEqualsWithNullAsNoop = p.getBoolean("expressionEqualsWithNullAsNoop", expressionEqualsWithNullAsNoop);
    expressionNativeIlike = p.getBoolean("expressionNativeIlike", expressionNativeIlike);

    dataTimeZone = p.get("dataTimeZone", dataTimeZone);
    asOfViewSuffix = p.get("asOfViewSuffix", asOfViewSuffix);
    asOfSysPeriod = p.get("asOfSysPeriod", asOfSysPeriod);
    historyTableSuffix = p.get("historyTableSuffix", historyTableSuffix);
    jdbcFetchSizeFindEach = p.getInt("jdbcFetchSizeFindEach", jdbcFetchSizeFindEach);
    jdbcFetchSizeFindList = p.getInt("jdbcFetchSizeFindList", jdbcFetchSizeFindList);
    databasePlatformName = p.get("databasePlatformName", databasePlatformName);

    uuidVersion = p.getEnum(UuidVersion.class, "uuidVersion", uuidVersion);
    uuidStateFile = p.get("uuidStateFile", uuidStateFile);
    uuidNodeId = p.get("uuidNodeId", uuidNodeId);

    localTimeWithNanos = p.getBoolean("localTimeWithNanos", localTimeWithNanos);
    jodaLocalTimeMode = p.get("jodaLocalTimeMode", jodaLocalTimeMode);

    defaultEnumType = p.getEnum(EnumType.class, "defaultEnumType", defaultEnumType);
    disableLazyLoading = p.getBoolean("disableLazyLoading", disableLazyLoading);
    lazyLoadBatchSize = p.getInt("lazyLoadBatchSize", lazyLoadBatchSize);
    queryBatchSize = p.getInt("queryBatchSize", queryBatchSize);

    jsonInclude = p.getEnum(JsonConfig.Include.class, "jsonInclude", jsonInclude);
    jsonDateTime = p.getEnum(JsonConfig.DateTime.class, "jsonDateTime", jsonDateTime);
    jsonDate = p.getEnum(JsonConfig.Date.class, "jsonDate", jsonDate);
    jsonMutationDetection = p.getEnum(MutationDetection.class, "jsonMutationDetection", jsonMutationDetection);

    skipDataSourceCheck = p.getBoolean("skipDataSourceCheck", skipDataSourceCheck);
    runMigration = p.getBoolean("migration.run", runMigration);
    ddlGenerate = p.getBoolean("ddl.generate", ddlGenerate);
    ddlRun = p.getBoolean("ddl.run", ddlRun);
    ddlExtra = p.getBoolean("ddl.extra", ddlExtra);
    ddlCreateOnly = p.getBoolean("ddl.createOnly", ddlCreateOnly);
    ddlInitSql = p.get("ddl.initSql", ddlInitSql);
    ddlSeedSql = p.get("ddl.seedSql", ddlSeedSql);
    ddlStrictMode = p.getBoolean("ddl.strictMode", ddlStrictMode);
    ddlPlaceholders = p.get("ddl.placeholders", ddlPlaceholders);
    ddlHeader = p.get("ddl.header", ddlHeader);

    // read tenant-configuration from config:
    // tenant.mode = NONE | DB | SCHEMA | CATALOG | PARTITION
    String mode = p.get("tenant.mode");
    if (mode != null) {
      for (TenantMode value : TenantMode.values()) {
        if (value.name().equalsIgnoreCase(mode)) {
          tenantMode = value;
          break;
        }
      }
    }

    currentTenantProvider = p.createInstance(CurrentTenantProvider.class, "tenant.currentTenantProvider", currentTenantProvider);
    tenantCatalogProvider = p.createInstance(TenantCatalogProvider.class, "tenant.catalogProvider", tenantCatalogProvider);
    tenantSchemaProvider = p.createInstance(TenantSchemaProvider.class, "tenant.schemaProvider", tenantSchemaProvider);
    tenantPartitionColumn = p.get("tenant.partitionColumn", tenantPartitionColumn);
    classes = readClasses(p);

    String mappingsProp = p.get("mappingLocations", null);
    mappingLocations = searchList(mappingsProp, mappingLocations);
  }

  private NamingConvention createNamingConvention(PropertiesWrapper properties, NamingConvention namingConvention) {
    NamingConvention nc = properties.createInstance(NamingConvention.class, "namingConvention", null);
    return (nc != null) ? nc : namingConvention;
  }

  /**
   * Build the list of classes from the comma delimited string.
   *
   * @param properties the properties
   * @return the classes
   */
  private Set<Class<?>> readClasses(PropertiesWrapper properties) {
    String classNames = properties.get("classes", null);
    if (classNames == null) {
      return classes;
    }

    Set<Class<?>> classList = new HashSet<>();
    String[] split = StringHelper.splitNames(classNames);
    for (String cn : split) {
      if (!"class".equalsIgnoreCase(cn)) {
        try {
          classList.add(Class.forName(cn));
        } catch (ClassNotFoundException e) {
          String msg = "Error registering class [" + cn + "] from [" + classNames + "]";
          throw new RuntimeException(msg, e);
        }
      }
    }
    return classList;
  }

  private List<String> searchList(String searchNames, List<String> defaultValue) {
    if (searchNames != null) {
      String[] entries = StringHelper.splitNames(searchNames);
      List<String> hitList = new ArrayList<>(entries.length);
      Collections.addAll(hitList, entries);
      return hitList;
    } else {
      return defaultValue;
    }
  }

  @Override
  public PersistBatch appliedPersistBatchOnCascade() {
    if (persistBatchOnCascade == PersistBatch.INHERIT) {
      // use the platform default (ALL except SQL Server which has NONE)
      return databasePlatform.persistBatchOnCascade();
    }
    return persistBatchOnCascade;
  }

  @Override
  public Object getObjectMapper() {
    return objectMapper;
  }

  @Override
  public void setObjectMapper(Object objectMapper) {
    this.objectMapper = objectMapper;
  }

  @Override
  public boolean isExpressionEqualsWithNullAsNoop() {
    return expressionEqualsWithNullAsNoop;
  }

  @Override
  public void setExpressionEqualsWithNullAsNoop(boolean expressionEqualsWithNullAsNoop) {
    this.expressionEqualsWithNullAsNoop = expressionEqualsWithNullAsNoop;
  }

  @Override
  public boolean isExpressionNativeIlike() {
    return expressionNativeIlike;
  }

  @Override
  public void setExpressionNativeIlike(boolean expressionNativeIlike) {
    this.expressionNativeIlike = expressionNativeIlike;
  }

  @Override
  public String getEnabledL2Regions() {
    return enabledL2Regions;
  }

  @Override
  public void setEnabledL2Regions(String enabledL2Regions) {
    this.enabledL2Regions = enabledL2Regions;
  }

  @Override
  public boolean isDisableL2Cache() {
    return disableL2Cache;
  }

  @Override
  public void setDisableL2Cache(boolean disableL2Cache) {
    this.disableL2Cache = disableL2Cache;
  }

  @Override
  public boolean isLocalOnlyL2Cache() {
    return localOnlyL2Cache;
  }

  @Override
  public void setLocalOnlyL2Cache(boolean localOnlyL2Cache) {
    this.localOnlyL2Cache = localOnlyL2Cache;
  }

  @Override
  public boolean isUseValidationNotNull() {
    return useValidationNotNull;
  }

  @Override
  public void setUseValidationNotNull(boolean useValidationNotNull) {
    this.useValidationNotNull = useValidationNotNull;
  }

  @Override
  public boolean isNotifyL2CacheInForeground() {
    return notifyL2CacheInForeground;
  }

  @Override
  public void setNotifyL2CacheInForeground(boolean notifyL2CacheInForeground) {
    this.notifyL2CacheInForeground = notifyL2CacheInForeground;
  }

  @Override
  public int getQueryPlanTTLSeconds() {
    return queryPlanTTLSeconds;
  }

  @Override
  public void setQueryPlanTTLSeconds(int queryPlanTTLSeconds) {
    this.queryPlanTTLSeconds = queryPlanTTLSeconds;
  }

  @Override
  public PlatformConfig newPlatformConfig(String propertiesPath, String platformPrefix) {
    if (properties == null) {
      properties = new Properties();
    }
    PropertiesWrapper p = new PropertiesWrapper(propertiesPath, platformPrefix, properties, classLoadConfig);
    PlatformConfig config = new PlatformConfig(platformConfig);
    config.loadSettings(p);
    return config;
  }

  @Override
  public void addMappingLocation(String mappingLocation) {
    if (mappingLocations == null) {
      mappingLocations = new ArrayList<>();
    }
    mappingLocations.add(mappingLocation);
  }

  @Override
  public List<String> getMappingLocations() {
    return mappingLocations;
  }

  @Override
  public void setMappingLocations(List<String> mappingLocations) {
    this.mappingLocations = mappingLocations;
  }

  @Override
  public boolean isIdGeneratorAutomatic() {
    return idGeneratorAutomatic;
  }

  @Override
  public void setIdGeneratorAutomatic(boolean idGeneratorAutomatic) {
    this.idGeneratorAutomatic = idGeneratorAutomatic;
  }

  @Override
  public boolean isQueryPlanEnable() {
    return queryPlanEnable;
  }

  @Override
  public void setQueryPlanEnable(boolean queryPlanEnable) {
    this.queryPlanEnable = queryPlanEnable;
  }

  @Override
  public long getQueryPlanThresholdMicros() {
    return queryPlanThresholdMicros;
  }

  @Override
  public void setQueryPlanThresholdMicros(long queryPlanThresholdMicros) {
    this.queryPlanThresholdMicros = queryPlanThresholdMicros;
  }

  @Override
  public boolean isQueryPlanCapture() {
    return queryPlanCapture;
  }

  @Override
  public void setQueryPlanCapture(boolean queryPlanCapture) {
    this.queryPlanCapture = queryPlanCapture;
  }

  @Override
  public long getQueryPlanCapturePeriodSecs() {
    return queryPlanCapturePeriodSecs;
  }

  @Override
  public void setQueryPlanCapturePeriodSecs(long queryPlanCapturePeriodSecs) {
    this.queryPlanCapturePeriodSecs = queryPlanCapturePeriodSecs;
  }

  @Override
  public long getQueryPlanCaptureMaxTimeMillis() {
    return queryPlanCaptureMaxTimeMillis;
  }

  @Override
  public void setQueryPlanCaptureMaxTimeMillis(long queryPlanCaptureMaxTimeMillis) {
    this.queryPlanCaptureMaxTimeMillis = queryPlanCaptureMaxTimeMillis;
  }

  @Override
  public int getQueryPlanCaptureMaxCount() {
    return queryPlanCaptureMaxCount;
  }

  @Override
  public void setQueryPlanCaptureMaxCount(int queryPlanCaptureMaxCount) {
    this.queryPlanCaptureMaxCount = queryPlanCaptureMaxCount;
  }

  @Override
  public QueryPlanListener getQueryPlanListener() {
    return queryPlanListener;
  }

  @Override
  public void setQueryPlanListener(QueryPlanListener queryPlanListener) {
    this.queryPlanListener = queryPlanListener;
  }

  @Override
  public boolean isDumpMetricsOnShutdown() {
    return dumpMetricsOnShutdown;
  }

  @Override
  public void setDumpMetricsOnShutdown(boolean dumpMetricsOnShutdown) {
    this.dumpMetricsOnShutdown = dumpMetricsOnShutdown;
  }

  @Override
  public String getDumpMetricsOptions() {
    return dumpMetricsOptions;
  }

  @Override
  public void setDumpMetricsOptions(String dumpMetricsOptions) {
    this.dumpMetricsOptions = dumpMetricsOptions;
  }

  @Override
  public boolean isLoadModuleInfo() {
    return loadModuleInfo;
  }

  /**
   * @deprecated - migrate to {@link #isLoadModuleInfo()}.
   */
  @Override
  @SuppressWarnings("removal")
  @Deprecated(forRemoval = true)
  public boolean isAutoLoadModuleInfo() {
    return loadModuleInfo;
  }

  @Override
  public void setLoadModuleInfo(boolean loadModuleInfo) {
    this.loadModuleInfo = loadModuleInfo;
  }

  @Override
  public Function<String, String> getMetricNaming() {
    return metricNaming;
  }

  @Override
  public void setMetricNaming(Function<String, String> metricNaming) {
    this.metricNaming = metricNaming;
  }

  public enum UuidVersion {
    VERSION4,
    VERSION1,
    VERSION1RND
  }
}
