package io.ebeaninternal.dbmigration.ddlgeneration.platform;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

import io.ebean.annotation.ConstraintMode;
import io.ebean.config.dbplatform.DatabasePlatform;
import io.ebeaninternal.dbmigration.ddlgeneration.DdlBuffer;
import io.ebeaninternal.dbmigration.ddlgeneration.DdlOptions;
import io.ebeaninternal.dbmigration.ddlgeneration.DdlWrite;
import io.ebeaninternal.dbmigration.migration.AlterColumn;
import io.ebeaninternal.dbmigration.migration.Column;

/**
 * DB2 platform specific DDL.
 */
public class DB2Ddl extends PlatformDdl {

  private Set<String> requiresReorgOnIndex = new HashSet<>();
  private Set<String> requiresReorgOnEnd = new HashSet<>();
  private int count;

  public DB2Ddl(DatabasePlatform platform) {
    super(platform);
    this.dropTableIfExists = "drop table ";
    this.dropSequenceIfExists = "drop sequence ";
    this.dropConstraintIfExists = "drop constraint";
    this.dropIndexIfExists = "drop index ";
    this.identitySuffix = " generated by default as identity";
    this.columnSetNull = "drop not null";
    this.columnSetType = "set data type ";
    this.inlineUniqueWhenNullable = false;
    this.updateNullWithDefault = "call sysproc.admin_cmd('reorg table ${table}') /*${column} reorg*/;\n" + this.updateNullWithDefault;
  }

  @Override
  public String alterColumnNotnull(String tableName, String columnName, boolean notnull) {
    requiresReorgOnIndex.add(tableName);
    requiresReorgOnEnd.add(tableName);
    return super.alterColumnNotnull(tableName, columnName, notnull);
  }

  @Override
  public void alterTableDropColumn(DdlBuffer buffer, String tableName, String columnName) throws IOException {
    requiresReorgOnIndex.add(tableName);
    requiresReorgOnEnd.add(tableName);
    super.alterTableDropColumn(buffer, tableName, columnName);
  }

  @Override
  public String alterColumnBaseAttributes(AlterColumn alter) {
    requiresReorgOnIndex.add(alter.getTableName());
    requiresReorgOnEnd.add(alter.getTableName());
    return super.alterColumnBaseAttributes(alter);
  }

  @Override
  public String alterColumnType(String tableName, String columnName, String type) {
    requiresReorgOnIndex.add(tableName);
    requiresReorgOnEnd.add(tableName);
    return super.alterColumnType(tableName, columnName, type);
  }

  @Override
  protected void tableCreated(String tableName) {
    requiresReorgOnIndex.add(tableName);
    requiresReorgOnEnd.add(tableName);
  }

  @Override
  public String alterTableAddUniqueConstraint(String tableName, String uqName, String[] columns,
      String[] nullableColumns) {
    StringBuilder sb = new StringBuilder(300);
    if (requiresReorgOnIndex.remove(tableName)) {
      reorgTable(tableName, sb);
    }
    requiresReorgOnEnd.add(tableName);
    if (nullableColumns == null || nullableColumns.length == 0) {
      sb.append("alter table ").append(tableName).append(" add constraint ").append(maxConstraintName(uqName))
          .append(" unique ");
      appendColumns(columns, sb);
      return sb.toString();
    }

    if (uqName == null) {
      throw new NullPointerException();
    }
    sb.append("create unique index ").append(uqName).append(" on ").append(tableName).append('(');

    for (int i = 0; i < columns.length; i++) {
      if (i > 0) {
        sb.append(",");
      }
      sb.append(columns[i]);
    }
    sb.append(") exclude null keys");
    return sb.toString();
  }

  @Override
  public String alterTableDropUniqueConstraint(String tableName, String uniqueConstraintName) {
    StringBuilder sb = new StringBuilder(300);
    if (requiresReorgOnIndex.remove(tableName)) {
      reorgTable(tableName, sb);
    }
    requiresReorgOnEnd.add(tableName);
    sb.append("drop index ").append(uniqueConstraintName);
    return sb.toString();
  }

  @Override
  public String createIndex(WriteCreateIndex create) {
    if (requiresReorgOnIndex.remove(create.getTableName())) {
      StringBuilder sb = new StringBuilder(300);
      reorgTable(create.getTableName(), sb);
      sb.append(super.createIndex(create));
      return sb.toString();
    }
    return super.createIndex(create);
  }

  @Override
  protected void appendForeignKeyOnUpdate(StringBuilder buffer, ConstraintMode mode) {
    // do nothing, no on update clause for db2
  }

  private void reorgTable(String tableName, StringBuilder sb) {
    sb.append("call sysproc.admin_cmd('reorg table ").append(tableName).append("') /* reorg #");
    sb.append(++count).append(" */;\n");
  }

  @Override
  public String dropSequence(String sequenceName) {
    StringBuilder sb = new StringBuilder(300);
    sb.append("delimiter $$\n");
    sb.append("begin\n");
    sb.append("if exists (select seqschema from syscat.sequences where seqschema = current_schema and seqname='")
        .append(sequenceName).append("') then\n");
    sb.append("  prepare stmt from 'drop sequence ").append(sequenceName).append("';\n");
    sb.append("  execute stmt;\n");
    sb.append("end if;\n");
    sb.append("end$$");
    return sb.toString();
  }
  
  
  // after all "alter" statements, we have to reorg the tables
  @Override
  public void generateEpilog(DdlWrite write) throws IOException {
    StringBuilder sb = new StringBuilder(300);
    for (String table : requiresReorgOnEnd) {
      reorgTable(table, sb);
    }
    write.applyHistoryTrigger().append(sb.toString());
    requiresReorgOnIndex.clear();
    requiresReorgOnEnd.clear();
  }

}
